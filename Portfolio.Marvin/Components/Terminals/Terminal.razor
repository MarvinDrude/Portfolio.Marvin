@using System.Net
@using Me.Memory.Buffers
@using Portfolio.Marvin.Components.Common
@using Portfolio.Marvin.Terminals

@implements IDisposable

@inject IJSRuntime JsRuntime
@inject TerminalCommandHandler CommandHandler

<div class="terminal" @onclick="@EventCallback.Factory.Create(this, OnClickInsideTerminal)">
   <div class="bar">
      <div class="left">
         <div class="tab">
            <span>New Terminal Window</span>
         </div>
      </div>
      <div class="right">
         <div class="btn"><SvgIcon Name="minimize" /></div>
         <div class="btn"><SvgIcon Name="maximize" /></div>
         <div class="btn"><SvgIcon Name="close" /></div>
      </div>
   </div>
   <div class="body" @ref="@_bodyRef">
      <div class="history">
      @foreach (var line in _lines)
      {
         <pre class="line">@(new MarkupString(line))</pre>
      }
      </div>
      <div class="input">
         <span>&gt; </span>
         <label class="hide" for="console-input">Input</label>
         <input 
            @ref="@_textAreaRef" 
            @bind="@_input" 
            @bind:event="oninput"
            @onkeydown="@(EventCallback.Factory.Create<KeyboardEventArgs>(this, OnKeyDown))" 
            type="text"
            id="console-input" rows="1"
            autocomplete="off" 
            autocorrect="off" 
            autocapitalize="off" 
            spellcheck="false" />
      </div>
   </div>
</div>

@code {

   private ElementReference _textAreaRef;
   private ElementReference _bodyRef;
   
   private CircularBuffer<string> _lines = new(_maxLines);
   private const int _maxLines = 100;

   private string? _input;
   private bool _shouldScroll;
   private bool _initialized;

   protected override Task OnInitializedAsync()
   {
      Reset();
      return base.OnInitializedAsync();
   }

   protected override async Task OnAfterRenderAsync(bool firstRender)
   {
      if (_shouldScroll)
      {
         _shouldScroll = false;
         await ScrollToBottom();
      }

      if (firstRender)
      {
         const string joke = "reallife";
         const string skills = "skills";

         await FireCommand(joke);
         await FireCommand(skills);
         
         await InvokeAsync(StateHasChanged);
         _initialized = true;
      }
   }

   private async Task FireCommand(string command)
   {
      _lines.Add(command);
         
      await CommandHandler.Execute(new TerminalContext()
      {
         Buffer = _lines,
         RawText = command
      });
   }

   private async Task OnClickInsideTerminal()
   {
      await _textAreaRef.FocusAsync(true);
   }

   private async Task OnKeyDown(KeyboardEventArgs args)
   {
      if (args.Key != "Enter" || !_initialized) return;

      var before = _input ?? string.Empty;
      before = WebUtility.HtmlEncode(before);
      
      _lines.Add(before);
      _input = "";

      await CommandHandler.Execute(new TerminalContext()
      {
         Buffer = _lines,
         RawText = before
      });

      _shouldScroll = true;
      await InvokeAsync(StateHasChanged);
   }

   private void Reset()
   {
      _lines.Dispose();
      _lines = new CircularBuffer<string>(_maxLines);
      
      _lines.Add("Welcome to PortfolioOS v1.0");
      _lines.Add(" ");
      _lines.Add(@" __  __                  _       ");
      _lines.Add(@"|  \/  | __ _ _ ____   _(_)_ __  ");
      _lines.Add(@"| |\/| |/ _` | '__\ \ / / | '_ \ ");
      _lines.Add(@"| |  | | (_| | |   \ V /| | | | |");
      _lines.Add(@"|_|  |_|\__,_|_|    \_/ |_|_| |_|");
      _lines.Add(" ");
      _lines.Add("Type 'help' to see available commands.");
   }

   private async Task ScrollToBottom()
   {
      await JsRuntime.InvokeVoidAsync("scrollToBottom", _bodyRef);
   }

   public void Dispose()
   {
      _lines.Dispose();
   }
}